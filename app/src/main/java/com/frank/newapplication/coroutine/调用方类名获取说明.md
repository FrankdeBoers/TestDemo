# 获取调用方类名功能说明

## 问题背景

在Kotlin扩展函数中，`this`指向的是接收者对象，而不是调用这个函数的类。例如：

```kotlin
fun CoroutineScope.launch1(block: suspend CoroutineScope.() -> Unit) {
    val name = CoroutineName(this.javaClass.name) // 这里获取的是CoroutineScope的类名
    launch(name, block)
}
```

## 解决方案

### 1. 使用堆栈跟踪获取调用方

通过`Thread.currentThread().stackTrace`获取调用栈，然后解析出真正的调用方类名。

### 2. 提供的工具类

#### CoroutineUtils 工具类

```kotlin
// 获取调用方的简单类名
val callerName = CoroutineUtils.getCallerClassName()

// 获取调用方的完整类名
val fullClassName = CoroutineUtils.getCallerFullClassName()

// 获取调用方的详细信息
val callerInfo = CoroutineUtils.getCallerInfo()
```

#### 扩展函数

```kotlin
// 带调用方信息的协程启动
GlobalScope.launchWithCaller {
    // 协程代码
}

// 简化版，只使用调用方类名
GlobalScope.launchWithCallerName {
    // 协程代码
}

// 详细版，包含方法名
GlobalScope.launchWithDetailedInfo {
    // 协程代码
}
```

## 使用示例

### 基本用法

```kotlin
class MyActivity : AppCompatActivity() {
    
    fun startCoroutine() {
        // 使用工具类获取调用方信息
        val callerName = CoroutineUtils.getCallerClassName()
        Log.i("TAG", "调用方类名: $callerName") // 输出: MyActivity
        
        val callerInfo = CoroutineUtils.getCallerInfo()
        Log.i("TAG", "调用方信息: $callerInfo") // 输出: MyActivity.startCoroutine:123
        
        // 使用扩展函数启动协程
        GlobalScope.launchWithCaller {
            Log.i("TAG", "协程执行")
        }
    }
}
```

### 在协程监控中使用

```kotlin
// 在协程性能监控中自动获取调用方信息
fun CoroutineScope.launchWithMonitoring(block: suspend CoroutineScope.() -> Unit) {
    val callerInfo = CoroutineUtils.getCallerInfo()
    val name = CoroutineName("${callerInfo.simpleClassName}.${callerInfo.methodName}")
    
    Log.i("Monitoring", "启动协程: $callerInfo")
    
    launch(name) {
        val startTime = System.currentTimeMillis()
        try {
            block()
        } finally {
            val duration = System.currentTimeMillis() - startTime
            Log.i("Monitoring", "协程完成: $callerInfo, 耗时: ${duration}ms")
        }
    }
}
```

## 技术原理

### 堆栈跟踪解析

1. **获取堆栈跟踪**：`Thread.currentThread().stackTrace`
2. **跳过系统帧**：过滤掉虚拟机、系统库等无关帧
3. **查找调用方**：找到第一个有效的调用方类
4. **提取信息**：获取类名、方法名、行号等

### 过滤规则

工具类会自动过滤以下类型的类：
- `kotlinx.coroutines` - 协程框架类
- `java.lang` - Java系统类
- `android` - Android框架类
- `androidx` - AndroidX库类
- `com.android` - Android系统类
- `dalvik` - 虚拟机类
- `sun.misc` - Sun系统类
- `jdk.internal` - JDK内部类

## 性能考虑

### 优点
- **准确性高**：能够准确获取调用方信息
- **无需修改调用点**：不需要传递额外参数
- **灵活性好**：可以获取多种信息（类名、方法名、行号）

### 缺点
- **性能开销**：获取堆栈跟踪有一定性能开销
- **运行时依赖**：依赖运行时堆栈信息

### 使用建议

1. **开发调试**：适合在开发阶段使用，帮助调试协程问题
2. **性能监控**：在性能监控场景中使用，记录协程来源
3. **生产环境**：谨慎使用，避免频繁调用影响性能
4. **缓存结果**：如果多次调用，考虑缓存结果

## 实际应用场景

### 1. 协程性能监控
```kotlin
// 自动记录协程来源，便于性能分析
GlobalScope.launchWithCaller {
    // 业务逻辑
}
```

### 2. 调试日志
```kotlin
// 在日志中显示协程来源
val callerInfo = CoroutineUtils.getCallerInfo()
Log.d("Coroutine", "协程启动: $callerInfo")
```

### 3. 异常追踪
```kotlin
// 在异常处理中记录协程来源
try {
    // 协程代码
} catch (e: Exception) {
    val callerInfo = CoroutineUtils.getCallerInfo()
    Log.e("Error", "协程异常: $callerInfo", e)
}
```

## 注意事项

1. **性能影响**：频繁调用会影响性能，建议在关键位置使用
2. **准确性**：在某些优化场景下（如内联函数），可能无法准确获取
3. **版本兼容**：不同Android版本和Kotlin版本的堆栈信息可能略有差异
4. **混淆影响**：代码混淆后，类名可能发生变化 