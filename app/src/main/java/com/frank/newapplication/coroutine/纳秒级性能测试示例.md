# 纳秒级性能测试示例

## 概述

CoroutinePerformanceAnalyzer现在使用纳秒级精度进行性能测量，提供更精确的性能数据。

## 纳秒级测量的优势

### 1. 更高精度
- **毫秒级**: 0.001ms = 1000ns，精度有限
- **纳秒级**: 1ns精度，可以测量微秒级操作

### 2. 更准确的性能分析
- 能够区分微秒级别的性能差异
- 提供更详细的性能分布信息
- 有助于发现细微的性能问题

### 3. 智能单位显示
- **< 1μs**: 显示为纳秒 (ns)
- **1μs - 1ms**: 显示为微秒 (μs)
- **> 1ms**: 显示为毫秒 (ms)

## 测试示例

### 基础测试
```kotlin
// 测试getCallerClassName的性能
val result = CoroutinePerformanceAnalyzer.analyzeGetCallerClassNamePerformance(
    iterations = 1000,
    warmupIterations = 100
)
println(result)
```

### 预期输出
```
📊 getCallerClassName 性能测试结果
=============================
总调用次数: 1000
总耗时: 45.123ms
平均耗时: 45.123μs
最小耗时: 32.456μs
最大耗时: 89.234μs
P50耗时: 43.567μs
P90耗时: 51.234μs
P95耗时: 56.789μs
P99耗时: 72.345μs
=============================
```

### 性能对比测试
```kotlin
// 对比不同方法的性能
val results = CoroutinePerformanceAnalyzer.compareMethodsPerformance(500)
val report = CoroutinePerformanceAnalyzer.generatePerformanceReport(results)
println(report)
```

### 预期输出
```
🚀 协程性能分析报告
=============================
测试时间: 2024-01-15 14:30:25
设备信息: Pixel 6 (Android 13)
=============================

📊 getCallerClassName 性能测试结果
=============================
总调用次数: 500
总耗时: 22.561ms
平均耗时: 45.122μs
最小耗时: 32.456μs
最大耗时: 89.234μs
P50耗时: 43.567μs
P90耗时: 51.234μs
P95耗时: 56.789μs
P99耗时: 72.345μs
=============================

📊 getCallerClassNameOptimized 性能测试结果
=============================
总调用次数: 500
总耗时: 16.228ms
平均耗时: 32.456μs
最小耗时: 25.123μs
最大耗时: 67.890μs
P50耗时: 31.234μs
P90耗时: 37.567μs
P95耗时: 41.123μs
P99耗时: 52.456μs
=============================

📈 性能对比分析
=============================
1. getCallerClassNameOptimized: 32.456μs
2. getCallerClassName: 45.122μs
=============================
```

## 性能分析要点

### 1. 微秒级差异
- 纳秒级测量可以清楚显示微秒级别的性能差异
- 例如：32.456μs vs 45.122μs，差异约12.7μs

### 2. 性能分布
- P50/P90/P95/P99指标提供详细的性能分布
- 有助于识别性能异常值

### 3. 优化效果量化
- 可以精确量化优化效果
- 例如：优化版比原始版快12.7μs (28%提升)

## 使用建议

### 1. 开发阶段
```kotlin
// 使用详细测试，了解性能瓶颈
val result = CoroutinePerformanceAnalyzer.analyzeGetCallerClassNamePerformance(1000)
Log.i("Performance", "详细性能分析: $result")
```

### 2. 性能优化
```kotlin
// 对比优化前后的性能
val before = CoroutinePerformanceAnalyzer.analyzeMethodPerformance("优化前", 500) { /* 原始代码 */ }
val after = CoroutinePerformanceAnalyzer.analyzeMethodPerformance("优化后", 500) { /* 优化代码 */ }
val report = CoroutinePerformanceAnalyzer.generatePerformanceReport(listOf(before, after))
```

### 3. 生产监控
```kotlin
// 轻量级监控，避免性能影响
if (BuildConfig.DEBUG) {
    val result = CoroutinePerformanceAnalyzer.analyzeGetCallerClassNamePerformance(100)
    Log.d("Performance", "性能监控: $result")
}
```

## 注意事项

### 1. 测试环境
- 纳秒级测量对测试环境要求较高
- 建议在相同设备上进行对比测试
- 避免在系统负载高时进行测试

### 2. 结果解读
- 关注相对性能差异，而非绝对数值
- 考虑测试误差和系统波动
- 多次测试取平均值

### 3. 实际应用
- 纳秒级精度主要用于性能分析和优化
- 生产环境建议使用轻量级监控
- 避免过度优化微秒级差异

## 总结

纳秒级性能测试提供了更精确的性能数据，有助于：
1. **精确量化**性能差异和优化效果
2. **详细分析**性能分布和异常值
3. **科学决策**性能优化策略
4. **持续监控**性能变化趋势

通过纳秒级测量，我们可以更好地理解和优化协程性能监控系统的性能表现。 